// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
    directUrl = env("DIRECT_URL")   
}

// --- CORE MODELS --- //
model Shop {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  type        String   // "local", "online", or "both"
  clerkOrgId  String   @unique // Clerk Organization ID
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Billing fields - simplified for Clerk billing
  planId              String?   @default("starter")
  planStatus          String?   @default("active") // active, past_due, canceled, trialing
  clerkSubscriptionId String?
  trialEndsAt         DateTime?
  
  // Usage tracking
  currentUsers        Int @default(0)
  currentProducts     Int @default(0)
  monthlyTransactions Int @default(0)
  
  // Enhanced address structure
  address     ShopAddress?
  
  // Business details
  contactInfo ShopContactInfo?
  
  // POS and scanner settings
  posSettings POSSettings?
  
  // Supported franchises
  supportedFranchises ShopFranchise[]
  
  // Relations
  users       User[]   @relation("ShopUsers")
  customers   Customer[]
  products    Product[]
  inventoryItems InventoryItem[]
  transactions Transaction[]
  buylists    Buylist[]
  storeCreditTransactions StoreCreditTransaction[]
  settings    ShopSettings?
  billingEvents BillingEvent[]
}

// Enhanced address model
model ShopAddress {
  id          String   @id @default(cuid())
  shopId      String   @unique
  street      String
  city        String
  state       String
  zipCode     String
  country     String   @default("US")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  shop        Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)
}

// Business contact information
model ShopContactInfo {
  id          String   @id @default(cuid())
  shopId      String   @unique
  phone       String?
  email       String?
  website     String?
  taxId       String?  // Business tax ID
  businessHours BusinessHours[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  shop        Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)
}

// Business hours
model BusinessHours {
  id              String   @id @default(cuid())
  contactInfoId   String
  dayOfWeek       Int      // 0 = Sunday, 1 = Monday, etc.
  openTime        String?  // "09:00"
  closeTime       String?  // "17:00"
  isClosed        Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  contactInfo     ShopContactInfo @relation(fields: [contactInfoId], references: [id], onDelete: Cascade)
  
  @@unique([contactInfoId, dayOfWeek])
}

// POS configuration settings
model POSSettings {
  id                    String @id @default(cuid())
  shopId                String @unique
  enableScanner         Boolean @default(true)
  scannerDeviceType     String? // "camera", "barcode", "nfc"
  enableReceipts        Boolean @default(true)
  receiptTemplate       String? // Custom receipt template
  enableCustomerDisplay Boolean @default(false)
  defaultPaymentMethod  PaymentMethod @default(CASH)
  taxRate               Float @default(0.0) // Default tax rate
  enableDiscounts       Boolean @default(true)
  maxDiscountPercent    Float @default(20.0)
  enableReturns         Boolean @default(true)
  returnWindowDays      Int @default(30)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  // Relations
  shop                  Shop @relation(fields: [shopId], references: [id], onDelete: Cascade)
}

// Supported franchises for each shop
model ShopFranchise {
  id          String   @id @default(cuid())
  shopId      String
  franchise   String   // "One Piece TCG", "Magic The Gathering", "Pokemon TCG"
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  shop        Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)
  
  @@unique([shopId, franchise])
  @@index([shopId, isActive])
}

model User {
  id       Int     @id @default(autoincrement())
  clerkId  String  @unique
  email    String  @unique
  name     String?
  shopId   String?               // FK to Shop (nullable for now)
  role     String?               // Store user role (admin, member) - synced from Clerk
  shop     Shop?   @relation("ShopUsers", fields: [shopId], references: [id])
  
  // Relations for staff actions
  transactions Transaction[] @relation("StaffTransactions")
  buylists     Buylist[]     @relation("StaffBuylists")
  storeCreditTransactions StoreCreditTransaction[] @relation("StaffCreditTransactions")
}

// --- CUSTOMER & STORE CREDIT --- //
model Customer {
  id            String   @id @default(cuid())
  shopId        String
  name          String
  phone         String
  currentCredit Float    @default(0) // Current available store credit
  totalEarned   Float    @default(0) // Total store credit earned (for reference)
  lastVisit     DateTime?
  isActive      Boolean  @default(true)
  notes         String?  // Staff notes about customer
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Relations
  shop          Shop     @relation(fields: [shopId], references: [id])
  transactions  Transaction[]
  storeCreditTransactions StoreCreditTransaction[]
  buylists      Buylist[] // Add missing relation
  
  @@unique([shopId, phone]) // Phone number as unique identifier
  @@index([shopId, isActive])
}

model StoreCreditTransaction {
  id            String   @id @default(cuid())
  customerId    String
  shopId        String
  type          StoreCreditType
  amount        Float
  balanceBefore Float
  balanceAfter  Float
  referenceId   String?  // Link to transaction or buylist
  referenceType ReferenceType?
  staffId       Int?     // Staff member who processed this - changed to Int
  notes         String?  // Reason for credit adjustment
  createdAt     DateTime @default(now())
  
  // Relations
  customer      Customer @relation(fields: [customerId], references: [id])
  shop          Shop     @relation(fields: [shopId], references: [id])
  staff         User?    @relation("StaffCreditTransactions", fields: [staffId], references: [id])
  
  @@index([customerId, createdAt])
  @@index([shopId, type, createdAt])
}

enum StoreCreditType {
  EARNED        // From buylist
  SPENT         // Used in transactions
  ADJUSTED      // Manual adjustment by staff
  REFUNDED      // Refund from transaction
}

enum ReferenceType {
  TRANSACTION   // Linked to a sale/purchase
  BUYLIST       // Linked to a buylist
  MANUAL        // Manual adjustment
  REFUND        // Refund credit
}

// --- PRODUCTS & INVENTORY --- //
model Product {
  id            String   @id @default(cuid())
  name          String
  setCode       String?   // e.g., OP06
  setName       String?   // e.g., "Awakening of the New Era"
  tcgLine       String    // e.g., "One Piece TCG"
  rarity        String?
  cardNumber    String?   // e.g., "OP06-001"
  imageUrl      String?
  tcgplayerId   String?   // for sync reference
  marketPrice   Float?    // Add for price tracking
  lastPriceUpdate DateTime? // Add for price freshness
  
  // Flexible fields for future expansion
  productType   String?   // "card", "booster_box", "etb", "accessory", etc.
  sku           String?   // Stock Keeping Unit for non-card products
  barcode       String?   // Universal Product Code
  description   String?   // Product description
  brand         String?   // Brand/manufacturer
  model         String?   // Model/variant
  
  // Franchise-specific attributes
  franchiseAttributes ProductFranchiseAttributes?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Relations
  shop          Shop     @relation(fields: [shopId], references: [id])
  shopId        String
  inventoryItems InventoryItem[]
  transactionItems TransactionItem[]
  buylistItems  BuylistItem[]
  
  @@unique([shopId, tcgLine, setCode, cardNumber]) // Prevent duplicates
  @@index([tcgplayerId]) // For price sync performance
  @@index([shopId, tcgLine]) // For franchise filtering
  @@index([productType]) // For product type filtering
  @@index([barcode]) // For barcode scanning
  @@index([sku]) // For SKU lookups
}

// Franchise-specific product attributes
model ProductFranchiseAttributes {
  id          String   @id @default(cuid())
  productId   String   @unique
  
  // One Piece TCG specific
  character   String?  // Character name
  cardType    String?  // Leader, Character, Event, Stage
  cost        Int?     // Card cost
  power       Int?     // Card power
  counter     Int?     // Counter power
  effect      String?  // Card effect text
  
  // Magic The Gathering specific
  manaCost    String?  // Mana cost
  manaValue   Int?     // Converted mana cost
  mtgCardType String?  // Creature, Instant, Sorcery, etc.
  subtypes    String[] // Card subtypes
  mtgFlavorText String?  // Flavor text
  
  // Pokemon TCG specific
  pokemonType String?  // Fire, Water, etc.
  hp          Int?     // Hit points
  attack1     String?  // First attack
  attack2     String?  // Second attack
  weakness    String?  // Weakness type
  resistance  String?  // Resistance type
  retreatCost Int?     // Retreat cost
  
  // Common attributes
  artist      String?  // Card artist
  cardText    String?  // Card rules text
  flavorText  String?  // Flavor text
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model InventoryItem {
  id            String   @id @default(cuid())
  shopId        String
  productId     String
  quantity      Int
  price         Float
  condition     Condition @default(NM) // Add condition tracking
  notes         String?   // Add for item-specific notes
  lastUpdated   DateTime  @updatedAt
  createdAt     DateTime @default(now())
  
  // Relations
  product       Product  @relation(fields: [productId], references: [id])
  shop          Shop     @relation(fields: [shopId], references: [id])
  
  @@unique([shopId, productId, condition]) // Prevent duplicate entries
  @@index([shopId, quantity]) // For low stock queries
}

enum Condition {
  NM  // Near Mint
  LP  // Lightly Played
  MP  // Moderately Played
  HP  // Heavily Played
  DMG // Damaged
}

// --- TRANSACTIONS --- //
model Transaction {
  id           String   @id @default(cuid())
  shopId       String
  customerId   String?  // Optional - for store credit tracking
  type         TransactionType
  staffId      Int?     // Changed to Int to match User.id
  customerName String?  // Fallback if no customer record
  customerPhone String? // Fallback if no customer record
  subtotal     Float
  tax          Float    @default(0)
  discount     Float    @default(0)
  totalAmount  Float
  amountPaid   Float    // Actual amount paid
  storeCreditUsed Float @default(0) // Amount of store credit used
  paymentMethod PaymentMethod @default(CASH)
  status       TransactionStatus @default(COMPLETED)
  notes        String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  shop         Shop     @relation(fields: [shopId], references: [id])
  customer     Customer? @relation(fields: [customerId], references: [id])
  staff        User?    @relation("StaffTransactions", fields: [staffId], references: [id])
  items        TransactionItem[]

  @@index([shopId, createdAt])
  @@index([customerId, createdAt])
  @@index([shopId, type, status])
}

model TransactionItem {
  id             String @id @default(cuid())
  transactionId  String
  productId      String
  quantity       Int
  pricePerUnit   Float
  condition      Condition @default(NM)
  
  // Relations
  transaction    Transaction @relation(fields: [transactionId], references: [id])
  product        Product     @relation(fields: [productId], references: [id])
  
  @@index([transactionId])
}

enum TransactionType {
  BUYIN    // Customer selling to shop
  CHECKOUT // Customer buying from shop
}

enum TransactionStatus {
  PENDING
  COMPLETED
  VOIDED
  REFUNDED
}

enum PaymentMethod {
  CASH
  CREDIT_CARD
  DEBIT_CARD
  STORE_CREDIT
  MIXED         // Combination of payment methods
}

// --- BUYLISTS --- //
model Buylist {
  id          String   @id @default(cuid())
  shopId      String
  customerId  String?  // Optional - for store credit
  staffId     Int?     // Changed to Int to match User.id
  customerName String? // Fallback if no customer record
  customerPhone String? // Fallback if no customer record
  status      BuylistStatus
  totalValue  Float
  storeCreditAmount Float @default(0) // Amount to add to store credit
  cashAmount  Float @default(0) // Amount to pay in cash
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  shop        Shop     @relation(fields: [shopId], references: [id])
  customer    Customer? @relation(fields: [customerId], references: [id])
  staff       User?    @relation("StaffBuylists", fields: [staffId], references: [id])
  items       BuylistItem[]

  @@index([shopId, status, createdAt])
}

model BuylistItem {
  id          String   @id @default(cuid())
  buylistId   String
  productId   String
  quantity    Int
  offerPrice  Float
  condition   Condition @default(NM)

  // Relations
  buylist     Buylist  @relation(fields: [buylistId], references: [id])
  product     Product  @relation(fields: [productId], references: [id])
}

enum BuylistStatus {
  PENDING
  APPROVED
  REJECTED
  CREDITED
}



// --- SHOP SETTINGS --- //
model ShopSettings {
  id                    String @id @default(cuid())
  shopId                String @unique
  defaultCurrency       String @default("USD")
  enableNotifications   Boolean @default(true)
  autoPriceSync         Boolean @default(true)
  lowStockThreshold     Int @default(5)
  
  // Store Credit Settings
  enableStoreCredit     Boolean @default(true)
  minCreditAmount       Float   @default(0)
  maxCreditAmount       Float?  // null = unlimited
  
  // Relations
  shop                  Shop @relation(fields: [shopId], references: [id])
}

// --- BILLING --- //
model BillingEvent {
  id        String   @id @default(cuid())
  shopId    String
  eventType String   // subscription.created, subscription.updated, payment.failed, etc.
  eventData Json
  createdAt DateTime @default(now())
  
  // Relations
  shop      Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)
  
  @@index([shopId, createdAt])
  @@index([eventType, createdAt])
}

// --- WAITLIST SYSTEM --- //
model WaitlistEntry {
  id          String   @id @default(cuid())
  email       String   @unique
  firstName   String?
  lastName    String?
  storeName   String?
  storeType   String?  // "TCG", "Comic", "Figure", "General", etc.
  expectedLaunch String? // "Q1 2024", "Q2 2024", etc.
  
  // Communication preferences
  emailUpdates Boolean @default(true)
  progressUpdates Boolean @default(true)
  launchNotifications Boolean @default(true)
  
  // Discount and tracking
  discountCode String? @unique // Generated 10% discount code
  discountUsed Boolean @default(false)
  
  // Metadata
  source      String?  // "landing_page", "pricing_page", etc.
  referrer    String?  // Where they came from
  ipAddress   String?
  userAgent   String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([email])
  @@index([storeType])
  @@index([createdAt])
}